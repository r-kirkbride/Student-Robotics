from sr.robot3 import *
import time
import math

class robot:
    
    def __init__(self):
        
        #Creates an instance of the robot object from sr.robot3 and saves it as in attribute to the instance of this class
        self.R = Robot() 
        
        markers = self.R.camera.see_ids()
        
        self.R.ruggeduino.command("s") #reset motor encoders

        #does not include middle markers
        self.corner0 = [25,26,27,0,1,2]
        self.corner1 = [4,5,6,7,8,9]
        self.corner2 = [11,12,13,14,15,16]
        self.corner3 = [18,19,20,21,22,23]
        self.wallMarkers = [self.corner0, self.corner1, self.corner2, self.corner3]
        
        self.zone = self.R.zone

        if self.zone == 3:
            self.homeMarkers = self.corner3
            #self.enemyMarkers = [25,26,27,0,1,2,4,5,6,7,8,9,11,12,13,14,15,16]
        elif self.zone == 2:
            self.homeMarkers = self.corner2
            #self.enemyMarkers = [25,26,27,0,1,2,4,5,6,7,8,9,18,19,20,21,22,23]
        elif self.zone == 1:
            self.homeMarkers = self.corner1
            #self.enemyMarkers = [25,26,27,0,1,2,11,12,13,14,15,16,18,19,20,21,22,23]
        else:
            self.homeMarkers = self.corner0
            #self.enemyMarkers = [4,5,6,7,8,9,11,12,13,14,15,16,18,19,20,21,22,23]
        
        

        self.R.ruggeduino.command("g")

        self.R.ruggeduino.command("d")
        time.sleep(0.5)
        self.R.ruggeduino.command("e")
    
    def fetch(self, targetMarkers):

        ###optional (assume not part of the rest of the code)
        ##to search for the closest marker out of targetMarkers it can see rather than just the first one it can see
        ##if we are to use it, we need to change the method to return the closest marker out of the list of targetMarkers we pass into it
        ##also we need to change what we pass to goToMarker just below + the if statement to see if we should grab tokens
        #target = self.searchForTokens(targetMarkers)


        ##takes in the list of wall markers. Faces and goes to first adjacent enemy marker it sees
        ##have it so that it stops a larger distance before the target wall marker than it would for a token
        #self.gotoMarker(targetMarkers)

        ##only goes for tokens once we have gone to the markers we really wanted rather than some intermediate markers
        #if targetMarkers == self.wallMarkers[(self.zone + 1) % 4]

            ##still takes in a list. Faces and goes to closest token
            #self.gotoMarker([73])

            ##grabs token
            #self.grabToken()

            ##does a 180 turn
            #self.rotateDeg(180)
        pass

    def retrive(self, targetMarkers):
        
        ###optional (assume not part of the rest of the code)
        ##to search for the closest target out of targetMarkers it can see rather than just the first one it can see
        ##if we are to use it, we need to change the method to return the closest marker out of the list of targetMarkers we pass into it
        ##also we need to change what we pass to goToMarker just below + the if statement to see if we should release tokens
        #target = self.searchForTokens(targetMarkers)

        ##takes in list of wall markers. Faces and goes to first home marker it sees
        ##have it so that it stops a larger distance before the target wall marker than it would for a token
        #self.gotoMarker(targetMarkers)

        

        ##only release tokens once we have gone to the markers we really wanted rather than some intermediate markers
        #if targetMarkers == self.homeMarkers

            ##releases token
            #self.releaseToken()

            ##does a 180 turn
            #self.rotateDeg(180)
        pass

    def main(self):

        while True:

            ##which markers we will be driving to in the fetch stage
            ##reason for this is that this variable can change if robot cant see desired markers
            ##therefore making it easy to redo the same fetch sequence but with different wall markers
            self.fetchTargetMarkers = self.wallMarkers[(self.zone + 1) % 4]
            self.repeat = True

            #repeats until repeat is not needed
            while self.repeat == True:
                self.repeat = False
                self.fetch(self.fetchTargetMarkers)
            


            ##which markers we will be driving to in the retrieve stage
            ##reason for this is that this variable can change if robot cant see desired markers
            ##therefore making it easy to redo the same retrieve sequence but with different wall markers
            self.retrieveTargetMarkers = self.homeMarkers
            self.repeat = True

            #repeats until repeat is not needed
            while self.repeat == True:
                self.repeat = False
                self.retrive(self.retrieveTargetMarkers)
